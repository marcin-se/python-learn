# -*- coding: utf-8 -*-

"""
    weatherapi

    This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
"""
forecast_codes = [1063,1066,1069,1072,1087,1150,1153,1168,1171,1183,1186,
                  1189,1192,1195,1198,1201,1204,1207,1240,1243,1246,1273]
from weatherapi.controllers.ap_is_controller import APIsController
from weatherapi.configuration import Configuration
from weatherapi.decorators import lazy_property
from datetime import datetime, timedelta
from os.path import getmtime
import jsonpickle
import json
import sys
import os


class WeatherForecast(object):

    config = Configuration

    @lazy_property
    def ap_is(self):
        return APIsController()

    def __init__(self, key=None):
        if key is not None:
            Configuration.key = key
        self.requests_dict = self.read_file_to_dict('db_requests.json')
        self.weather_dict = self.load_forecast('db_weather.json', 'Katowice')

    def __str__(self):
        return self

    def __iter__(self):
        self.counter = 0
        return self

    def __next__(self):
        if len(self.requests_dict) <= self.counter:
            raise StopIteration
        indx = list(self.requests_dict)[self.counter]
        self.counter += 1
        return indx

    def __getitem__(self, w_date):
        if w_date in self.requests_dict:
            return self.requests_dict[w_date]
        else:
            return 'Nie wiem'

    def items(self):
        answer = self.read_file_to_dict('db_requests.json')
        for i in range(len(list(answer))):
            yield list(answer.items())[i]

    def read_file_to_dict(self, file_name):
        '''funkcja pobierająca dane ze źródłowego pliku (JSON) '''
        if os.path.exists(file_name):
            with open(file_name, 'r', newline='', encoding='utf-8') as file:
                working_dict = json.load(file)
                return working_dict
        return False, sys.stderr.write('Błąd pliku!')

    def save_dict_to_file(self, file_name, dict_name):
        '''metoda zapisująca dobowe dane pogodowe do pliku (JSON)'''
        working_dict = self.read_file_to_dict(file_name)
        new_dict = {**working_dict, **dict_name}
        new_dict = self.sort_dict(new_dict)
        with open(file_name, 'w', newline='\n', encoding='utf-8') as file:
            json.dump(new_dict, file)
        return True

    def load_forecast(self, file_name, q):
        time_file = getmtime(file_name)
        time_now = datetime.now().timestamp()
        new_dict_h, new_dict_f = {}, {}
        if time_now - time_file < 3600 * 24:
            new_dict = self.read_file_to_dict(file_name)
        else:
            for dy in range(8):
                dth = (datetime.today() - timedelta(days=dy)).strftime(
                                                                   '%Y-%m-%d')
                response_h = json.loads(self.get_history(q=q, dt=dth,
                                                                  enddt=None))
                local_dat_h = response_h['forecast']['forecastday'][0]['date']
                forec_codh = response_h['forecast']['forecastday'][0]['day'] \
                                                        ['condition']['code']
                forec_h = 'Będzie padać!' if forec_codh in forecast_codes \
                                                      else 'Nie będzie padać.'
                new_dict_h[local_dat_h] = forec_h
                dtf = (datetime.today() + timedelta(days=dy)).strftime(
                                                                   '%Y-%m-%d')
                response_f = json.loads(self.get_forecast(q=q, days=1, dt=dtf,
                                                                 unixdt=None))
                local_dat_f = response_f['forecast']['forecastday'][0]['date']
                forec_codf = response_f['forecast']['forecastday'][0]['day'] \
                                                         ['condition']['code']
                forec_f = 'Będzie padać!' if forec_codf in forecast_codes \
                                                       else 'Nie będzie padać.'
                new_dict_f[local_dat_f] = forec_f
            new_dict = {**new_dict_h, **new_dict_f}
            self.save_dict_to_file(file_name, new_dict)
        return new_dict

    def get_current(self, q):
        resp = jsonpickle.encode(self.ap_is.get_realtime_weather(
                                                              q=q, lang='pl'))
        return resp

    def get_history(self, q, dt, enddt):
        '''get_history_weather(q, dt, *unixdt, *end_dt, *u_end_dt, *hour, *lang)'''
        resp = jsonpickle.encode(self.ap_is.get_history_weather(q=q, dt=dt,
                                                              unixdt=None,
                                                              end_dt=enddt,
                                                              unixend_dt=None,
                                                              hour=None,
                                                              lang='pl'))
        return resp

    def get_forecast(self, q, days, dt, unixdt):
        '''get_forecast_weather(q, days, *dt, *unixdt, *hour, *lang)'''
        resp = jsonpickle.encode(self.ap_is.get_forecast_weather(q=q, days=days,
                                                              dt=dt,
                                                              unixdt=unixdt,
                                                              hour=None,
                                                              lang='pl'))
        return resp

    @staticmethod
    def sort_dict(dict_name):
        work_list = []
        for k, v in dict_name.items():
            work_list.append([k, v])
        work_list.sort()
        dict_name = {}
        for i in range(len(work_list)):
            dict_name[work_list[i][0]] = work_list[i][1]
        return dict_name
